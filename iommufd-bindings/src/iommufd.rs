/* automatically generated by rust-bindgen 0.72.0 */

pub const __BITS_PER_LONG: u32 = 64;
pub const __FD_SETSIZE: u32 = 1024;
pub const _IOC_NRBITS: u32 = 8;
pub const _IOC_TYPEBITS: u32 = 8;
pub const _IOC_SIZEBITS: u32 = 14;
pub const _IOC_DIRBITS: u32 = 2;
pub const _IOC_NRMASK: u32 = 255;
pub const _IOC_TYPEMASK: u32 = 255;
pub const _IOC_SIZEMASK: u32 = 16383;
pub const _IOC_DIRMASK: u32 = 3;
pub const _IOC_NRSHIFT: u32 = 0;
pub const _IOC_TYPESHIFT: u32 = 8;
pub const _IOC_SIZESHIFT: u32 = 16;
pub const _IOC_DIRSHIFT: u32 = 30;
pub const _IOC_NONE: u32 = 0;
pub const _IOC_WRITE: u32 = 1;
pub const _IOC_READ: u32 = 2;
pub const IOC_IN: u32 = 1073741824;
pub const IOC_OUT: u32 = 2147483648;
pub const IOC_INOUT: u32 = 3221225472;
pub const IOCSIZE_MASK: u32 = 1073676288;
pub const IOCSIZE_SHIFT: u32 = 16;
pub const IOMMUFD_TYPE: u8 = 59u8;
pub type __s8 = ::std::os::raw::c_schar;
pub type __u8 = ::std::os::raw::c_uchar;
pub type __s16 = ::std::os::raw::c_short;
pub type __u16 = ::std::os::raw::c_ushort;
pub type __s32 = ::std::os::raw::c_int;
pub type __u32 = ::std::os::raw::c_uint;
pub type __s64 = ::std::os::raw::c_longlong;
pub type __u64 = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct __kernel_fd_set {
    pub fds_bits: [::std::os::raw::c_ulong; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __kernel_fd_set"][::std::mem::size_of::<__kernel_fd_set>() - 128usize];
    ["Alignment of __kernel_fd_set"][::std::mem::align_of::<__kernel_fd_set>() - 8usize];
    ["Offset of field: __kernel_fd_set::fds_bits"]
        [::std::mem::offset_of!(__kernel_fd_set, fds_bits) - 0usize];
};
pub type __kernel_sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __kernel_key_t = ::std::os::raw::c_int;
pub type __kernel_mqd_t = ::std::os::raw::c_int;
pub type __kernel_old_uid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_gid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_dev_t = ::std::os::raw::c_ulong;
pub type __kernel_long_t = ::std::os::raw::c_long;
pub type __kernel_ulong_t = ::std::os::raw::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = ::std::os::raw::c_uint;
pub type __kernel_pid_t = ::std::os::raw::c_int;
pub type __kernel_ipc_pid_t = ::std::os::raw::c_int;
pub type __kernel_uid_t = ::std::os::raw::c_uint;
pub type __kernel_gid_t = ::std::os::raw::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = ::std::os::raw::c_int;
pub type __kernel_uid32_t = ::std::os::raw::c_uint;
pub type __kernel_gid32_t = ::std::os::raw::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_ptrdiff_t = __kernel_long_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct __kernel_fsid_t {
    pub val: [::std::os::raw::c_int; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __kernel_fsid_t"][::std::mem::size_of::<__kernel_fsid_t>() - 8usize];
    ["Alignment of __kernel_fsid_t"][::std::mem::align_of::<__kernel_fsid_t>() - 4usize];
    ["Offset of field: __kernel_fsid_t::val"]
        [::std::mem::offset_of!(__kernel_fsid_t, val) - 0usize];
};
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = ::std::os::raw::c_longlong;
pub type __kernel_old_time_t = __kernel_long_t;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_time64_t = ::std::os::raw::c_longlong;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ::std::os::raw::c_int;
pub type __kernel_clockid_t = ::std::os::raw::c_int;
pub type __kernel_caddr_t = *mut ::std::os::raw::c_char;
pub type __kernel_uid16_t = ::std::os::raw::c_ushort;
pub type __kernel_gid16_t = ::std::os::raw::c_ushort;
pub type __s128 = i128;
pub type __u128 = u128;
pub type __le16 = __u16;
pub type __be16 = __u16;
pub type __le32 = __u32;
pub type __be32 = __u32;
pub type __le64 = __u64;
pub type __be64 = __u64;
pub type __sum16 = __u16;
pub type __wsum = __u32;
pub type __poll_t = ::std::os::raw::c_uint;
pub const IOMMUFD_CMD_BASE: _bindgen_ty_1 = 128;
pub const IOMMUFD_CMD_DESTROY: _bindgen_ty_1 = 128;
pub const IOMMUFD_CMD_IOAS_ALLOC: _bindgen_ty_1 = 129;
pub const IOMMUFD_CMD_IOAS_ALLOW_IOVAS: _bindgen_ty_1 = 130;
pub const IOMMUFD_CMD_IOAS_COPY: _bindgen_ty_1 = 131;
pub const IOMMUFD_CMD_IOAS_IOVA_RANGES: _bindgen_ty_1 = 132;
pub const IOMMUFD_CMD_IOAS_MAP: _bindgen_ty_1 = 133;
pub const IOMMUFD_CMD_IOAS_UNMAP: _bindgen_ty_1 = 134;
pub const IOMMUFD_CMD_OPTION: _bindgen_ty_1 = 135;
pub const IOMMUFD_CMD_VFIO_IOAS: _bindgen_ty_1 = 136;
pub const IOMMUFD_CMD_HWPT_ALLOC: _bindgen_ty_1 = 137;
pub const IOMMUFD_CMD_GET_HW_INFO: _bindgen_ty_1 = 138;
#[doc = " DOC: General ioctl format\n\n The ioctl interface follows a general format to allow for extensibility. Each\n ioctl is passed in a structure pointer as the argument providing the size of\n the structure in the first u32. The kernel checks that any structure space\n beyond what it understands is 0. This allows userspace to use the backward\n compatible portion while consistently using the newer, larger, structures.\n\n ioctls use a standard meaning for common errnos:\n\n  - ENOTTY: The IOCTL number itself is not supported at all\n  - E2BIG: The IOCTL number is supported, but the provided structure has\n    non-zero in a part the kernel does not understand.\n  - EOPNOTSUPP: The IOCTL number is supported, and the structure is\n    understood, however a known field has a value the kernel does not\n    understand or support.\n  - EINVAL: Everything about the IOCTL was understood, but a field is not\n    correct.\n  - ENOENT: An ID or IOVA provided does not exist.\n  - ENOMEM: Out of memory.\n  - EOVERFLOW: Mathematics overflowed.\n\n As well as additional errnos, within specific ioctls."]
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
#[doc = " struct iommu_destroy - ioctl(IOMMU_DESTROY)\n @size: sizeof(struct iommu_destroy)\n @id: iommufd object ID to destroy. Can be any destroyable object type.\n\n Destroy any object held within iommufd."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct iommu_destroy {
    pub size: __u32,
    pub id: __u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of iommu_destroy"][::std::mem::size_of::<iommu_destroy>() - 8usize];
    ["Alignment of iommu_destroy"][::std::mem::align_of::<iommu_destroy>() - 4usize];
    ["Offset of field: iommu_destroy::size"][::std::mem::offset_of!(iommu_destroy, size) - 0usize];
    ["Offset of field: iommu_destroy::id"][::std::mem::offset_of!(iommu_destroy, id) - 4usize];
};
#[doc = " struct iommu_ioas_alloc - ioctl(IOMMU_IOAS_ALLOC)\n @size: sizeof(struct iommu_ioas_alloc)\n @flags: Must be 0\n @out_ioas_id: Output IOAS ID for the allocated object\n\n Allocate an IO Address Space (IOAS) which holds an IO Virtual Address (IOVA)\n to memory mapping."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct iommu_ioas_alloc {
    pub size: __u32,
    pub flags: __u32,
    pub out_ioas_id: __u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of iommu_ioas_alloc"][::std::mem::size_of::<iommu_ioas_alloc>() - 12usize];
    ["Alignment of iommu_ioas_alloc"][::std::mem::align_of::<iommu_ioas_alloc>() - 4usize];
    ["Offset of field: iommu_ioas_alloc::size"]
        [::std::mem::offset_of!(iommu_ioas_alloc, size) - 0usize];
    ["Offset of field: iommu_ioas_alloc::flags"]
        [::std::mem::offset_of!(iommu_ioas_alloc, flags) - 4usize];
    ["Offset of field: iommu_ioas_alloc::out_ioas_id"]
        [::std::mem::offset_of!(iommu_ioas_alloc, out_ioas_id) - 8usize];
};
#[doc = " struct iommu_iova_range - ioctl(IOMMU_IOVA_RANGE)\n @start: First IOVA\n @last: Inclusive last IOVA\n\n An interval in IOVA space."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct iommu_iova_range {
    pub start: __u64,
    pub last: __u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of iommu_iova_range"][::std::mem::size_of::<iommu_iova_range>() - 16usize];
    ["Alignment of iommu_iova_range"][::std::mem::align_of::<iommu_iova_range>() - 8usize];
    ["Offset of field: iommu_iova_range::start"]
        [::std::mem::offset_of!(iommu_iova_range, start) - 0usize];
    ["Offset of field: iommu_iova_range::last"]
        [::std::mem::offset_of!(iommu_iova_range, last) - 8usize];
};
#[doc = " struct iommu_ioas_iova_ranges - ioctl(IOMMU_IOAS_IOVA_RANGES)\n @size: sizeof(struct iommu_ioas_iova_ranges)\n @ioas_id: IOAS ID to read ranges from\n @num_iovas: Input/Output total number of ranges in the IOAS\n @__reserved: Must be 0\n @allowed_iovas: Pointer to the output array of struct iommu_iova_range\n @out_iova_alignment: Minimum alignment required for mapping IOVA\n\n Query an IOAS for ranges of allowed IOVAs. Mapping IOVA outside these ranges\n is not allowed. num_iovas will be set to the total number of iovas and\n the allowed_iovas[] will be filled in as space permits.\n\n The allowed ranges are dependent on the HW path the DMA operation takes, and\n can change during the lifetime of the IOAS. A fresh empty IOAS will have a\n full range, and each attached device will narrow the ranges based on that\n device's HW restrictions. Detaching a device can widen the ranges. Userspace\n should query ranges after every attach/detach to know what IOVAs are valid\n for mapping.\n\n On input num_iovas is the length of the allowed_iovas array. On output it is\n the total number of iovas filled in. The ioctl will return -EMSGSIZE and set\n num_iovas to the required value if num_iovas is too small. In this case the\n caller should allocate a larger output array and re-issue the ioctl.\n\n out_iova_alignment returns the minimum IOVA alignment that can be given\n to IOMMU_IOAS_MAP/COPY. IOVA's must satisfy::\n\n   starting_iova % out_iova_alignment == 0\n   (starting_iova + length) % out_iova_alignment == 0\n\n out_iova_alignment can be 1 indicating any IOVA is allowed. It cannot\n be higher than the system PAGE_SIZE."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct iommu_ioas_iova_ranges {
    pub size: __u32,
    pub ioas_id: __u32,
    pub num_iovas: __u32,
    pub __reserved: __u32,
    pub allowed_iovas: __u64,
    pub out_iova_alignment: __u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of iommu_ioas_iova_ranges"][::std::mem::size_of::<iommu_ioas_iova_ranges>() - 32usize];
    ["Alignment of iommu_ioas_iova_ranges"]
        [::std::mem::align_of::<iommu_ioas_iova_ranges>() - 8usize];
    ["Offset of field: iommu_ioas_iova_ranges::size"]
        [::std::mem::offset_of!(iommu_ioas_iova_ranges, size) - 0usize];
    ["Offset of field: iommu_ioas_iova_ranges::ioas_id"]
        [::std::mem::offset_of!(iommu_ioas_iova_ranges, ioas_id) - 4usize];
    ["Offset of field: iommu_ioas_iova_ranges::num_iovas"]
        [::std::mem::offset_of!(iommu_ioas_iova_ranges, num_iovas) - 8usize];
    ["Offset of field: iommu_ioas_iova_ranges::__reserved"]
        [::std::mem::offset_of!(iommu_ioas_iova_ranges, __reserved) - 12usize];
    ["Offset of field: iommu_ioas_iova_ranges::allowed_iovas"]
        [::std::mem::offset_of!(iommu_ioas_iova_ranges, allowed_iovas) - 16usize];
    ["Offset of field: iommu_ioas_iova_ranges::out_iova_alignment"]
        [::std::mem::offset_of!(iommu_ioas_iova_ranges, out_iova_alignment) - 24usize];
};
#[doc = " struct iommu_ioas_allow_iovas - ioctl(IOMMU_IOAS_ALLOW_IOVAS)\n @size: sizeof(struct iommu_ioas_allow_iovas)\n @ioas_id: IOAS ID to allow IOVAs from\n @num_iovas: Input/Output total number of ranges in the IOAS\n @__reserved: Must be 0\n @allowed_iovas: Pointer to array of struct iommu_iova_range\n\n Ensure a range of IOVAs are always available for allocation. If this call\n succeeds then IOMMU_IOAS_IOVA_RANGES will never return a list of IOVA ranges\n that are narrower than the ranges provided here. This call will fail if\n IOMMU_IOAS_IOVA_RANGES is currently narrower than the given ranges.\n\n When an IOAS is first created the IOVA_RANGES will be maximally sized, and as\n devices are attached the IOVA will narrow based on the device restrictions.\n When an allowed range is specified any narrowing will be refused, ie device\n attachment can fail if the device requires limiting within the allowed range.\n\n Automatic IOVA allocation is also impacted by this call. MAP will only\n allocate within the allowed IOVAs if they are present.\n\n This call replaces the entire allowed list with the given list."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct iommu_ioas_allow_iovas {
    pub size: __u32,
    pub ioas_id: __u32,
    pub num_iovas: __u32,
    pub __reserved: __u32,
    pub allowed_iovas: __u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of iommu_ioas_allow_iovas"][::std::mem::size_of::<iommu_ioas_allow_iovas>() - 24usize];
    ["Alignment of iommu_ioas_allow_iovas"]
        [::std::mem::align_of::<iommu_ioas_allow_iovas>() - 8usize];
    ["Offset of field: iommu_ioas_allow_iovas::size"]
        [::std::mem::offset_of!(iommu_ioas_allow_iovas, size) - 0usize];
    ["Offset of field: iommu_ioas_allow_iovas::ioas_id"]
        [::std::mem::offset_of!(iommu_ioas_allow_iovas, ioas_id) - 4usize];
    ["Offset of field: iommu_ioas_allow_iovas::num_iovas"]
        [::std::mem::offset_of!(iommu_ioas_allow_iovas, num_iovas) - 8usize];
    ["Offset of field: iommu_ioas_allow_iovas::__reserved"]
        [::std::mem::offset_of!(iommu_ioas_allow_iovas, __reserved) - 12usize];
    ["Offset of field: iommu_ioas_allow_iovas::allowed_iovas"]
        [::std::mem::offset_of!(iommu_ioas_allow_iovas, allowed_iovas) - 16usize];
};
pub const iommufd_ioas_map_flags_IOMMU_IOAS_MAP_FIXED_IOVA: iommufd_ioas_map_flags = 1;
pub const iommufd_ioas_map_flags_IOMMU_IOAS_MAP_WRITEABLE: iommufd_ioas_map_flags = 2;
pub const iommufd_ioas_map_flags_IOMMU_IOAS_MAP_READABLE: iommufd_ioas_map_flags = 4;
#[doc = " enum iommufd_ioas_map_flags - Flags for map and copy\n @IOMMU_IOAS_MAP_FIXED_IOVA: If clear the kernel will compute an appropriate\n                             IOVA to place the mapping at\n @IOMMU_IOAS_MAP_WRITEABLE: DMA is allowed to write to this mapping\n @IOMMU_IOAS_MAP_READABLE: DMA is allowed to read from this mapping"]
pub type iommufd_ioas_map_flags = ::std::os::raw::c_uint;
#[doc = " struct iommu_ioas_map - ioctl(IOMMU_IOAS_MAP)\n @size: sizeof(struct iommu_ioas_map)\n @flags: Combination of enum iommufd_ioas_map_flags\n @ioas_id: IOAS ID to change the mapping of\n @__reserved: Must be 0\n @user_va: Userspace pointer to start mapping from\n @length: Number of bytes to map\n @iova: IOVA the mapping was placed at. If IOMMU_IOAS_MAP_FIXED_IOVA is set\n        then this must be provided as input.\n\n Set an IOVA mapping from a user pointer. If FIXED_IOVA is specified then the\n mapping will be established at iova, otherwise a suitable location based on\n the reserved and allowed lists will be automatically selected and returned in\n iova.\n\n If IOMMU_IOAS_MAP_FIXED_IOVA is specified then the iova range must currently\n be unused, existing IOVA cannot be replaced."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct iommu_ioas_map {
    pub size: __u32,
    pub flags: __u32,
    pub ioas_id: __u32,
    pub __reserved: __u32,
    pub user_va: __u64,
    pub length: __u64,
    pub iova: __u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of iommu_ioas_map"][::std::mem::size_of::<iommu_ioas_map>() - 40usize];
    ["Alignment of iommu_ioas_map"][::std::mem::align_of::<iommu_ioas_map>() - 8usize];
    ["Offset of field: iommu_ioas_map::size"]
        [::std::mem::offset_of!(iommu_ioas_map, size) - 0usize];
    ["Offset of field: iommu_ioas_map::flags"]
        [::std::mem::offset_of!(iommu_ioas_map, flags) - 4usize];
    ["Offset of field: iommu_ioas_map::ioas_id"]
        [::std::mem::offset_of!(iommu_ioas_map, ioas_id) - 8usize];
    ["Offset of field: iommu_ioas_map::__reserved"]
        [::std::mem::offset_of!(iommu_ioas_map, __reserved) - 12usize];
    ["Offset of field: iommu_ioas_map::user_va"]
        [::std::mem::offset_of!(iommu_ioas_map, user_va) - 16usize];
    ["Offset of field: iommu_ioas_map::length"]
        [::std::mem::offset_of!(iommu_ioas_map, length) - 24usize];
    ["Offset of field: iommu_ioas_map::iova"]
        [::std::mem::offset_of!(iommu_ioas_map, iova) - 32usize];
};
#[doc = " struct iommu_ioas_copy - ioctl(IOMMU_IOAS_COPY)\n @size: sizeof(struct iommu_ioas_copy)\n @flags: Combination of enum iommufd_ioas_map_flags\n @dst_ioas_id: IOAS ID to change the mapping of\n @src_ioas_id: IOAS ID to copy from\n @length: Number of bytes to copy and map\n @dst_iova: IOVA the mapping was placed at. If IOMMU_IOAS_MAP_FIXED_IOVA is\n            set then this must be provided as input.\n @src_iova: IOVA to start the copy\n\n Copy an already existing mapping from src_ioas_id and establish it in\n dst_ioas_id. The src iova/length must exactly match a range used with\n IOMMU_IOAS_MAP.\n\n This may be used to efficiently clone a subset of an IOAS to another, or as a\n kind of 'cache' to speed up mapping. Copy has an efficiency advantage over\n establishing equivalent new mappings, as internal resources are shared, and\n the kernel will pin the user memory only once."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct iommu_ioas_copy {
    pub size: __u32,
    pub flags: __u32,
    pub dst_ioas_id: __u32,
    pub src_ioas_id: __u32,
    pub length: __u64,
    pub dst_iova: __u64,
    pub src_iova: __u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of iommu_ioas_copy"][::std::mem::size_of::<iommu_ioas_copy>() - 40usize];
    ["Alignment of iommu_ioas_copy"][::std::mem::align_of::<iommu_ioas_copy>() - 8usize];
    ["Offset of field: iommu_ioas_copy::size"]
        [::std::mem::offset_of!(iommu_ioas_copy, size) - 0usize];
    ["Offset of field: iommu_ioas_copy::flags"]
        [::std::mem::offset_of!(iommu_ioas_copy, flags) - 4usize];
    ["Offset of field: iommu_ioas_copy::dst_ioas_id"]
        [::std::mem::offset_of!(iommu_ioas_copy, dst_ioas_id) - 8usize];
    ["Offset of field: iommu_ioas_copy::src_ioas_id"]
        [::std::mem::offset_of!(iommu_ioas_copy, src_ioas_id) - 12usize];
    ["Offset of field: iommu_ioas_copy::length"]
        [::std::mem::offset_of!(iommu_ioas_copy, length) - 16usize];
    ["Offset of field: iommu_ioas_copy::dst_iova"]
        [::std::mem::offset_of!(iommu_ioas_copy, dst_iova) - 24usize];
    ["Offset of field: iommu_ioas_copy::src_iova"]
        [::std::mem::offset_of!(iommu_ioas_copy, src_iova) - 32usize];
};
#[doc = " struct iommu_ioas_unmap - ioctl(IOMMU_IOAS_UNMAP)\n @size: sizeof(struct iommu_ioas_unmap)\n @ioas_id: IOAS ID to change the mapping of\n @iova: IOVA to start the unmapping at\n @length: Number of bytes to unmap, and return back the bytes unmapped\n\n Unmap an IOVA range. The iova/length must be a superset of a previously\n mapped range used with IOMMU_IOAS_MAP or IOMMU_IOAS_COPY. Splitting or\n truncating ranges is not allowed. The values 0 to U64_MAX will unmap\n everything."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct iommu_ioas_unmap {
    pub size: __u32,
    pub ioas_id: __u32,
    pub iova: __u64,
    pub length: __u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of iommu_ioas_unmap"][::std::mem::size_of::<iommu_ioas_unmap>() - 24usize];
    ["Alignment of iommu_ioas_unmap"][::std::mem::align_of::<iommu_ioas_unmap>() - 8usize];
    ["Offset of field: iommu_ioas_unmap::size"]
        [::std::mem::offset_of!(iommu_ioas_unmap, size) - 0usize];
    ["Offset of field: iommu_ioas_unmap::ioas_id"]
        [::std::mem::offset_of!(iommu_ioas_unmap, ioas_id) - 4usize];
    ["Offset of field: iommu_ioas_unmap::iova"]
        [::std::mem::offset_of!(iommu_ioas_unmap, iova) - 8usize];
    ["Offset of field: iommu_ioas_unmap::length"]
        [::std::mem::offset_of!(iommu_ioas_unmap, length) - 16usize];
};
pub const iommufd_option_IOMMU_OPTION_RLIMIT_MODE: iommufd_option = 0;
pub const iommufd_option_IOMMU_OPTION_HUGE_PAGES: iommufd_option = 1;
#[doc = " enum iommufd_option - ioctl(IOMMU_OPTION_RLIMIT_MODE) and\n                       ioctl(IOMMU_OPTION_HUGE_PAGES)\n @IOMMU_OPTION_RLIMIT_MODE:\n    Change how RLIMIT_MEMLOCK accounting works. The caller must have privilege\n    to invoke this. Value 0 (default) is user based accouting, 1 uses process\n    based accounting. Global option, object_id must be 0\n @IOMMU_OPTION_HUGE_PAGES:\n    Value 1 (default) allows contiguous pages to be combined when generating\n    iommu mappings. Value 0 disables combining, everything is mapped to\n    PAGE_SIZE. This can be useful for benchmarking.  This is a per-IOAS\n    option, the object_id must be the IOAS ID."]
pub type iommufd_option = ::std::os::raw::c_uint;
pub const iommufd_option_ops_IOMMU_OPTION_OP_SET: iommufd_option_ops = 0;
pub const iommufd_option_ops_IOMMU_OPTION_OP_GET: iommufd_option_ops = 1;
#[doc = " enum iommufd_option_ops - ioctl(IOMMU_OPTION_OP_SET) and\n                           ioctl(IOMMU_OPTION_OP_GET)\n @IOMMU_OPTION_OP_SET: Set the option's value\n @IOMMU_OPTION_OP_GET: Get the option's value"]
pub type iommufd_option_ops = ::std::os::raw::c_uint;
#[doc = " struct iommu_option - iommu option multiplexer\n @size: sizeof(struct iommu_option)\n @option_id: One of enum iommufd_option\n @op: One of enum iommufd_option_ops\n @__reserved: Must be 0\n @object_id: ID of the object if required\n @val64: Option value to set or value returned on get\n\n Change a simple option value. This multiplexor allows controlling options\n on objects. IOMMU_OPTION_OP_SET will load an option and IOMMU_OPTION_OP_GET\n will return the current value."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct iommu_option {
    pub size: __u32,
    pub option_id: __u32,
    pub op: __u16,
    pub __reserved: __u16,
    pub object_id: __u32,
    pub val64: __u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of iommu_option"][::std::mem::size_of::<iommu_option>() - 24usize];
    ["Alignment of iommu_option"][::std::mem::align_of::<iommu_option>() - 8usize];
    ["Offset of field: iommu_option::size"][::std::mem::offset_of!(iommu_option, size) - 0usize];
    ["Offset of field: iommu_option::option_id"]
        [::std::mem::offset_of!(iommu_option, option_id) - 4usize];
    ["Offset of field: iommu_option::op"][::std::mem::offset_of!(iommu_option, op) - 8usize];
    ["Offset of field: iommu_option::__reserved"]
        [::std::mem::offset_of!(iommu_option, __reserved) - 10usize];
    ["Offset of field: iommu_option::object_id"]
        [::std::mem::offset_of!(iommu_option, object_id) - 12usize];
    ["Offset of field: iommu_option::val64"][::std::mem::offset_of!(iommu_option, val64) - 16usize];
};
pub const iommufd_vfio_ioas_op_IOMMU_VFIO_IOAS_GET: iommufd_vfio_ioas_op = 0;
pub const iommufd_vfio_ioas_op_IOMMU_VFIO_IOAS_SET: iommufd_vfio_ioas_op = 1;
pub const iommufd_vfio_ioas_op_IOMMU_VFIO_IOAS_CLEAR: iommufd_vfio_ioas_op = 2;
#[doc = " enum iommufd_vfio_ioas_op - IOMMU_VFIO_IOAS_* ioctls\n @IOMMU_VFIO_IOAS_GET: Get the current compatibility IOAS\n @IOMMU_VFIO_IOAS_SET: Change the current compatibility IOAS\n @IOMMU_VFIO_IOAS_CLEAR: Disable VFIO compatibility"]
pub type iommufd_vfio_ioas_op = ::std::os::raw::c_uint;
#[doc = " struct iommu_vfio_ioas - ioctl(IOMMU_VFIO_IOAS)\n @size: sizeof(struct iommu_vfio_ioas)\n @ioas_id: For IOMMU_VFIO_IOAS_SET the input IOAS ID to set\n           For IOMMU_VFIO_IOAS_GET will output the IOAS ID\n @op: One of enum iommufd_vfio_ioas_op\n @__reserved: Must be 0\n\n The VFIO compatibility support uses a single ioas because VFIO APIs do not\n support the ID field. Set or Get the IOAS that VFIO compatibility will use.\n When VFIO_GROUP_SET_CONTAINER is used on an iommufd it will get the\n compatibility ioas, either by taking what is already set, or auto creating\n one. From then on VFIO will continue to use that ioas and is not effected by\n this ioctl. SET or CLEAR does not destroy any auto-created IOAS."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct iommu_vfio_ioas {
    pub size: __u32,
    pub ioas_id: __u32,
    pub op: __u16,
    pub __reserved: __u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of iommu_vfio_ioas"][::std::mem::size_of::<iommu_vfio_ioas>() - 12usize];
    ["Alignment of iommu_vfio_ioas"][::std::mem::align_of::<iommu_vfio_ioas>() - 4usize];
    ["Offset of field: iommu_vfio_ioas::size"]
        [::std::mem::offset_of!(iommu_vfio_ioas, size) - 0usize];
    ["Offset of field: iommu_vfio_ioas::ioas_id"]
        [::std::mem::offset_of!(iommu_vfio_ioas, ioas_id) - 4usize];
    ["Offset of field: iommu_vfio_ioas::op"][::std::mem::offset_of!(iommu_vfio_ioas, op) - 8usize];
    ["Offset of field: iommu_vfio_ioas::__reserved"]
        [::std::mem::offset_of!(iommu_vfio_ioas, __reserved) - 10usize];
};
#[doc = " struct iommu_hwpt_alloc - ioctl(IOMMU_HWPT_ALLOC)\n @size: sizeof(struct iommu_hwpt_alloc)\n @flags: Must be 0\n @dev_id: The device to allocate this HWPT for\n @pt_id: The IOAS to connect this HWPT to\n @out_hwpt_id: The ID of the new HWPT\n @__reserved: Must be 0\n\n Explicitly allocate a hardware page table object. This is the same object\n type that is returned by iommufd_device_attach() and represents the\n underlying iommu driver's iommu_domain kernel object.\n\n A HWPT will be created with the IOVA mappings from the given IOAS."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct iommu_hwpt_alloc {
    pub size: __u32,
    pub flags: __u32,
    pub dev_id: __u32,
    pub pt_id: __u32,
    pub out_hwpt_id: __u32,
    pub __reserved: __u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of iommu_hwpt_alloc"][::std::mem::size_of::<iommu_hwpt_alloc>() - 24usize];
    ["Alignment of iommu_hwpt_alloc"][::std::mem::align_of::<iommu_hwpt_alloc>() - 4usize];
    ["Offset of field: iommu_hwpt_alloc::size"]
        [::std::mem::offset_of!(iommu_hwpt_alloc, size) - 0usize];
    ["Offset of field: iommu_hwpt_alloc::flags"]
        [::std::mem::offset_of!(iommu_hwpt_alloc, flags) - 4usize];
    ["Offset of field: iommu_hwpt_alloc::dev_id"]
        [::std::mem::offset_of!(iommu_hwpt_alloc, dev_id) - 8usize];
    ["Offset of field: iommu_hwpt_alloc::pt_id"]
        [::std::mem::offset_of!(iommu_hwpt_alloc, pt_id) - 12usize];
    ["Offset of field: iommu_hwpt_alloc::out_hwpt_id"]
        [::std::mem::offset_of!(iommu_hwpt_alloc, out_hwpt_id) - 16usize];
    ["Offset of field: iommu_hwpt_alloc::__reserved"]
        [::std::mem::offset_of!(iommu_hwpt_alloc, __reserved) - 20usize];
};
#[doc = " struct iommu_hw_info_vtd - Intel VT-d hardware information\n\n @flags: Must be 0\n @__reserved: Must be 0\n\n @cap_reg: Value of Intel VT-d capability register defined in VT-d spec\n           section 11.4.2 Capability Register.\n @ecap_reg: Value of Intel VT-d capability register defined in VT-d spec\n            section 11.4.3 Extended Capability Register.\n\n User needs to understand the Intel VT-d specification to decode the\n register value."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct iommu_hw_info_vtd {
    pub flags: __u32,
    pub __reserved: __u32,
    pub cap_reg: __u64,
    pub ecap_reg: __u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of iommu_hw_info_vtd"][::std::mem::size_of::<iommu_hw_info_vtd>() - 24usize];
    ["Alignment of iommu_hw_info_vtd"][::std::mem::align_of::<iommu_hw_info_vtd>() - 8usize];
    ["Offset of field: iommu_hw_info_vtd::flags"]
        [::std::mem::offset_of!(iommu_hw_info_vtd, flags) - 0usize];
    ["Offset of field: iommu_hw_info_vtd::__reserved"]
        [::std::mem::offset_of!(iommu_hw_info_vtd, __reserved) - 4usize];
    ["Offset of field: iommu_hw_info_vtd::cap_reg"]
        [::std::mem::offset_of!(iommu_hw_info_vtd, cap_reg) - 8usize];
    ["Offset of field: iommu_hw_info_vtd::ecap_reg"]
        [::std::mem::offset_of!(iommu_hw_info_vtd, ecap_reg) - 16usize];
};
pub const iommu_hw_info_type_IOMMU_HW_INFO_TYPE_NONE: iommu_hw_info_type = 0;
pub const iommu_hw_info_type_IOMMU_HW_INFO_TYPE_INTEL_VTD: iommu_hw_info_type = 1;
#[doc = " enum iommu_hw_info_type - IOMMU Hardware Info Types\n @IOMMU_HW_INFO_TYPE_NONE: Used by the drivers that do not report hardware\n                           info\n @IOMMU_HW_INFO_TYPE_INTEL_VTD: Intel VT-d iommu info type"]
pub type iommu_hw_info_type = ::std::os::raw::c_uint;
#[doc = " struct iommu_hw_info - ioctl(IOMMU_GET_HW_INFO)\n @size: sizeof(struct iommu_hw_info)\n @flags: Must be 0\n @dev_id: The device bound to the iommufd\n @data_len: Input the length of a user buffer in bytes. Output the length of\n            data that kernel supports\n @data_uptr: User pointer to a user-space buffer used by the kernel to fill\n             the iommu type specific hardware information data\n @out_data_type: Output the iommu hardware info type as defined in the enum\n                 iommu_hw_info_type.\n @__reserved: Must be 0\n\n Query an iommu type specific hardware information data from an iommu behind\n a given device that has been bound to iommufd. This hardware info data will\n be used to sync capabilities between the virtual iommu and the physical\n iommu, e.g. a nested translation setup needs to check the hardware info, so\n a guest stage-1 page table can be compatible with the physical iommu.\n\n To capture an iommu type specific hardware information data, @data_uptr and\n its length @data_len must be provided. Trailing bytes will be zeroed if the\n user buffer is larger than the data that kernel has. Otherwise, kernel only\n fills the buffer using the given length in @data_len. If the ioctl succeeds,\n @data_len will be updated to the length that kernel actually supports,\n @out_data_type will be filled to decode the data filled in the buffer\n pointed by @data_uptr. Input @data_len == zero is allowed."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct iommu_hw_info {
    pub size: __u32,
    pub flags: __u32,
    pub dev_id: __u32,
    pub data_len: __u32,
    pub data_uptr: __u64,
    pub out_data_type: __u32,
    pub __reserved: __u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of iommu_hw_info"][::std::mem::size_of::<iommu_hw_info>() - 32usize];
    ["Alignment of iommu_hw_info"][::std::mem::align_of::<iommu_hw_info>() - 8usize];
    ["Offset of field: iommu_hw_info::size"][::std::mem::offset_of!(iommu_hw_info, size) - 0usize];
    ["Offset of field: iommu_hw_info::flags"]
        [::std::mem::offset_of!(iommu_hw_info, flags) - 4usize];
    ["Offset of field: iommu_hw_info::dev_id"]
        [::std::mem::offset_of!(iommu_hw_info, dev_id) - 8usize];
    ["Offset of field: iommu_hw_info::data_len"]
        [::std::mem::offset_of!(iommu_hw_info, data_len) - 12usize];
    ["Offset of field: iommu_hw_info::data_uptr"]
        [::std::mem::offset_of!(iommu_hw_info, data_uptr) - 16usize];
    ["Offset of field: iommu_hw_info::out_data_type"]
        [::std::mem::offset_of!(iommu_hw_info, out_data_type) - 24usize];
    ["Offset of field: iommu_hw_info::__reserved"]
        [::std::mem::offset_of!(iommu_hw_info, __reserved) - 28usize];
};
